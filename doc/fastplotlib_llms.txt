### fastplotlib Documentation for LLMs

#### 1. Overview

fastplotlib is a high-performance, interactive scientific plotting library for Python. It is built on the `pygfx` rendering engine, which utilizes modern graphics backends like Vulkan, Metal, or DX12 via WGPU. This allows for GPU-accelerated visualization of large-scale data. The library is designed with an expressive and intuitive API, similar in feel to NumPy, to facilitate rapid prototyping and exploratory data analysis. fastplotlib is currently in a late alpha stage.

- **Homepage:** https://www.fastplotlib.org/
- **Repository:** https://github.com/fastplotlib/fastplotlib
- **License:** Apache 2.0

#### 2. Key Features

- **GPU-Accelerated:** Leverages the GPU for fast rendering of complex scenes and large datasets.
- **Interactive API:** An expressive, array-like API for manipulating plot elements dynamically.
- **Cross-Platform & Framework-Agnostic:** Runs on Linux, Windows, and macOS. It can be used in Jupyter Lab, PyQt/PySide applications, GLFW windows, and wxPython.
- **Multiple Graphic Types:** Supports images, lines, scatter plots, text, line collections, and more.
- **Event System:** Comprehensive event system for handling user interactions (mouse, keyboard) and property changes on graphics.
- **UI Integration:** Easily integrates with UI libraries like `imgui` and `ipywidgets`.
- **Large Data Exploration:** Optimized for exploring and rendering large-scale scientific data, including multi-dimensional arrays and real-time data streams.

#### 3. Core Concepts

The main components of a fastplotlib visualization are:

- **`Figure`**: The top-level container for the entire visualization. It can hold one or more `Subplot` objects in a grid or custom layout. It manages the canvas, renderer, and controllers.
- **`Subplot`**: A single plotting area within a `Figure`. It contains the graphics, axes, and its own camera and controller. You add graphics to a `Subplot`.
- **`Graphic`**: A visual representation of data. Examples include `ImageGraphic`, `LineGraphic`, and `ScatterGraphic`. Graphics are added to `Subplot` objects. They have mutable properties (called "features") like `data`, `colors`, `cmap`, and `visible` that can be changed dynamically.
- **`GraphicCollection`**: A collection of `Graphic` objects that can be manipulated as a group, such as `LineCollection` or `LineStack`.
- **Selectors**: Interactive tools like `LinearSelector` and `LinearRegionSelector` that can be added to graphics to select data points or regions.
- **`ImageWidget`**: A high-level widget for displaying and navigating multi-dimensional image data (2D, 3D, 4D) with built-in sliders and a histogram LUT.

#### 4. Installation

fastplotlib can be installed using pip. Optional dependencies can be included for different environments.

**Recommended installation (includes JupyterLab and `imgui` support):**
```bash
pip install -U "fastplotlib[notebook,imgui]"
```

**Minimal installation:**
```bash
pip install -U fastplotlib
```

**For use in JupyterLab:**
```bash
pip install -U "fastplotlib[notebook]"
```

**For `imgui` support:**
```bash
pip install -U "fastplotlib[imgui]"
```

For optimal performance in notebooks, it is recommended to install `simplejpeg` after installing `libjpeg-turbo`.

#### 5. Basic Usage

The API is designed to be concise and intuitive.

**Example: Simple Image Plot**
```python
import fastplotlib as fpl
import imageio.v3 as iio

# Create a Figure with a default 1x1 subplot layout
fig = fpl.Figure()

# Load image data
data = iio.imread("imageio:camera.png")

# Get the subplot at position and add an image graphic
image_graphic = fig.add_image(data=data, name="camera")

# Show the plot
fig.show()

# Run the event loop (for standalone scripts)
if __name__ == "__main__":
    fpl.loop.run()
```

#### 6. The API in Detail

##### 6.1. Creating Figures and Subplots

```python
# Create a figure with a single subplot
fig = fpl.Figure()
subplot = fig

# Create a 2x3 grid of subplots
fig_grid = fpl.Figure(shape=(2, 3))

# Access a specific subplot
subplot_1_2 = fig_grid

# Sync cameras and controllers across all subplots
fig_sync = fpl.Figure(shape=(2, 2), controller_ids="sync")
```

##### 6.2. Adding Graphics

Graphics are added to subplots.

```python
# Add a line plot from x, y data
xs = np.linspace(-10, 10, 100)
ys = np.sin(xs)
sine_data = np.column_stack([xs, ys])
line = subplot.add_line(data=sine_data, colors="magenta", thickness=3)

# Add a scatter plot
points = np.random.rand(100, 2) * 200
scatter = subplot.add_scatter(data=points, sizes=5, cmap="viridis")

# Add an image
img_data = np.random.rand(256, 256)
image = subplot.add_image(data=img_data, cmap="jet")
```

##### 6.3. Interacting with Graphic Properties

Graphic properties can be accessed and modified directly. Many properties support NumPy-style slicing.

```python
# Change the colormap of an image
image.cmap = "hot"

# Change the contrast limits
image.vmin = 0.2
image.vmax = 0.8

# Change the color of a line
line.colors = "cyan"

# Modify a slice of the line's data
line.data[50:, 1] *= 0.5 # Halve the y-values of the second half of the line

# Use boolean indexing on colors
line.colors[line.data[:, 1] < 0] = "red"

# Change a slice of a line's colormap
line.cmap[0:25] = "viridis"
```

##### 6.4. Event Handling

Event handlers can be attached to graphics or the figure's renderer to respond to user input or property changes.

**Attaching an event handler:**
```python
# Using a decorator
@image.add_event_handler("click")
def my_click_handler(event):
    # event.pick_info contains info about the clicked element
    print(f"Clicked on Image at index: {event.pick_info['index']}")

# Using the method
def my_cmap_handler(event):
    # event.info contains details about the property change
    print(f"Image colormap changed to: {event.info['value']}")

image.add_event_handler(my_cmap_handler, "cmap")
```

**Common Event Types:**
-   **Canvas Events:** `click`, `double_click`, `pointer_down`, `pointer_up`, `pointer_move`, `wheel`, `key_down`, `key_up`.
-   **Property Events:** A new event is fired whenever a mutable property (like `data`, `colors`, `cmap`, `vmin`, `visible`, etc.) is changed. The event type is the name of the property.

##### 6.5. Using Selectors

Selectors are tools for interactive data selection.

```python
# Add a vertical line selector to a line graphic
selector = line.add_linear_selector(axis='x')

@selector.add_event_handler("selection")
def on_selection(event):
    # Get the data index under the selector
    selected_index = event.get_selected_index()
    # event.info['value'] has the new selector position
    print(f"Selector at index: {selected_index}, position: {event.info['value']:.2f}")
```

#### 7. Supported Environments

- **JupyterLab:** `fastplotlib` integrates with `ipywidgets`. Figures can be displayed inline, in a `sidecar`, or laid out using `VBox` and `HBox`. This works with remote kernels.
- **Qt (PyQt6/PySide6):** Figures can be embedded as widgets in a Qt application.
- **GLFW:** Figures can be shown in a standalone GLFW window. This is the default for running scripts from the terminal.
- **ipython:** Supports Qt or GLFW backends. To use Qt, run `%gui qt` before importing `fastplotlib`.

#### 8. Contribution Guide

- Contributions are welcome and follow the Git feature branch workflow.
- Fork the repository, create a new branch for your feature or bugfix.
- Code style follows `black`.
- Tests are written using `pytest`. For visual changes, screenshot-based tests are used. Ground-truth images are stored in `git-lfs`.
- Pull requests should be made against the `main` branch.
- Public methods and classes require `numpydoc` style docstrings with type annotations.

#### 9. Project Governance

- The project is led by **Maintainers** (core developers) and guided by an **Advisory Committee**.
- Decisions are made through a "consensus-seeking" process, primarily on the GitHub issue tracker and discussions.
- The project has a formal Code of Conduct and a conflict resolution process managed by a neutral moderator.

```text
#### 10. Animations

fastplotlib allows you to define functions that are called on every render cycle, making it easy to create animations.

- **`add_animations(callback)`**: This method can be called on a `Subplot` object.
- **Callback Function**: The provided callback function must accept the `Subplot` instance as its only argument. Inside this function, you can update the data or properties of any graphic within that subplot.

**Example: Animating a Sine Wave**
```python
import fastplotlib as fpl
import numpy as np

# Initial data
xs = np.linspace(0, 10, 100)
ys = np.sin(xs)
data = np.column_stack([xs, ys])

fig = fpl.Figure()
line = fig.add_line(data=data, name="dynamic_sine")

# This animation function is called on every frame
def update_wave(subplot):
    # `subplot.graphics` holds all graphics. We select ours by name.
    # Update the y-values of the line's data buffer.
    # This is highly efficient as it only updates the buffer on the GPU.
    subplot["dynamic_sine"].data[:, 1] = np.sin(xs + fpl.loop.time)

# Register the animation function with the subplot
fig.add_animations(update_wave)

fig.show()

if __name__ == "__main__":
    fpl.loop.run()


#### 11. Advanced Graphics

##### 11.1. LineCollection and LineStack

- **`LineCollection`**: Efficiently plots and manages a large number of `LineGraphic` objects. All lines in the collection can be manipulated together (e.g., changing `cmap`) or individually by indexing the collection.
- **`LineStack`**: A subclass of `LineCollection` that automatically arranges lines in a stack with a specified separation along the y-axis.

**Example: Plotting a `LineStack`**```python
import numpy as np
import fastplotlib as fpl

# Create data for 10 sine waves
xs = np.linspace(0, np.pi * 10, 100)
ys = np.sin(xs)
sine_wave = np.column_stack([xs, ys])
data_stack = np.stack([sine_wave] * 10) # Shape: (10, 100, 2)

fig = fpl.Figure()

# Add a line stack, each line will be separated by 3 units on the y-axis
# The colormap 'jet' will be applied across the stack of lines
line_stack = fig.add_line_stack(
    data_stack,
    thickness=3,
    separation=3,
    cmap="jet"
)

fig.show()

if __name__ == "__main__":
    fpl.loop.run()
```

Slicing `LineCollection` and `LineStack` objects allows for powerful, vectorized modifications.

```python
# Change the color of the first 3 lines in the stack
line_stack[0:3].colors = "magenta"

# Use fancy indexing based on a property
# Make all lines with thickness > 4 red
line_stack[line_stack.thickness > 4].colors = "r"

# Slice both the collection and the data within each line
# Set the alpha of the first 50 points of every other line to 0.5
line_stack[::2].colors[:50, -1] = 0.5
```

#### 12. UI Integration

fastplotlib is designed to work seamlessly with popular UI toolkits for building interactive applications.

##### 12.1. `imgui`

`imgui-bundle` allows for creating immediate-mode GUIs that are rendered directly onto the same canvas as the plot. This makes them backend-agnostic (working in Jupyter, Qt, and GLFW).

- **`ImguiFigure`**: A special figure class for `imgui` integration.
- **`EdgeWindow`**: A base class for creating custom UI windows that are docked to the edges of the plot.
- **`figure.add_gui(my_gui)`**: Adds a custom GUI instance to the figure.

**Conceptual Example: `imgui` UI**
```python
from fastplotlib.ui import EdgeWindow
from imgui_bundle import imgui

class MyGUI(EdgeWindow):
    def __init__(self, figure, size, location, title, line_graphic):
        super().__init__(figure, size, location, title)
        self.line = line_graphic
        self.amplitude = 1.0

    # The update method is called every frame to draw the UI
    def update(self):
        # Create a slider for amplitude
        changed, new_amplitude = imgui.slider_float(
            "Amplitude", self.amplitude, 0.1, 5.0
        )
        if changed:
            self.amplitude = new_amplitude
            # Update the line data based on the new amplitude
            self.line.data[:, 1] = np.sin(xs) * self.amplitude

# In main script:
# fig = fpl.ImguiFigure()
# line = fig.add_line(...)
# my_gui = MyGUI(fig, size=250, location="right", title="Controls", line_graphic=line)
# fig.add_gui(my_gui)
# fig.show()
```

##### 12.2. `ipywidgets`

In JupyterLab, `ipywidgets` can be used to control plot features. The `figure.show()` method returns a widget that can be composed with other ipywidgets.

**Conceptual Example: `ipywidgets`**
```python
from ipywidgets import FloatSlider, VBox

# fig = fpl.Figure()
# line = fig.add_line(...)

# Create a slider
slider = FloatSlider(min=0.1, max=5.0, value=1.0, description="Amplitude")

# Define a callback
def update_amplitude(change):
    line.data[:, 1] = np.sin(xs) * change["new"]

# Link the slider to the callback
slider.observe(update_amplitude, "value")

# Display the figure and the slider together
VBox([fig.show(), slider])
```

#### 13. ImageWidget

The `ImageWidget` is a high-level component that simplifies the visualization of multi-dimensional image and video data. It automatically creates:

- A `Figure` with subplots for each image.
- Sliders for navigating through extra dimensions (e.g., time or z-stacks).
- A histogram LUT (Look-Up Table) for interactive contrast adjustment (`vmin`/`vmax`).
- A colorbar with a right-click menu to change colormaps.

**Example: Viewing a Video**
```python
import fastplotlib as fpl
import imageio.v3 as iio

# Load a video file (T, H, W, C)
video_data = iio.imread("imageio:cockatoo.mp4")

# The ImageWidget automatically creates a slider for the 't' dimension
iw = fpl.ImageWidget(data=video_data, rgb=True)

iw.show()
```

#### 14. Coordinate Systems

Understanding the different coordinate systems is key for advanced interactions.

- **World Space**: The 3D space where all graphics (`world_object`s) reside. The camera looks into this space.
- **Data Space**: World space transformed by a graphic's specific `offset` and `rotation`. This is the coordinate system of the raw data provided to the graphic.
- **Screen Space**: The 2D pixel space of the canvas/window. The renderer projects from world space to screen space.
- **`subplot.map_screen_to_world((x, y))`**: A crucial utility function to convert mouse coordinates (screen space) to the corresponding location in the 3D world space.

#### 15. GPU Management

Since `fastplotlib` is GPU-based, understanding how to manage the GPU is important for performance and stability.

- **Driver Requirements**: Up-to-date and properly configured GPU drivers are essential. Vulkan is used on Linux/Windows, and Metal on macOS.
- **Adapter Selection**: `fastplotlib` will automatically select a GPU (adapter), prioritizing discrete GPUs. You can manually inspect and select a GPU.
- **`fpl.enumerate_adapters()`**: Returns a list of available GPU adapters.
- **`fpl.select_adapter(adapter)`**: Sets the adapter to be used. **This must be called before creating any `Figure`**.
- **`fpl.print_wgpu_report()`**: Prints a detailed diagnostic report, including the active GPU, memory usage, and supported features. This is useful for debugging.


#### 16. Deeper Architectural Concepts

For advanced users and contributors, understanding the underlying architecture is beneficial. This is based on the `pygfx` rendering engine.

##### 16.1. Graphics Architecture

- **`Graphic` Base Class**: All graphic types (`ImageGraphic`, `LineGraphic`, etc.) inherit from the base `Graphic` class. It manages common properties and wraps a `pygfx.WorldObject`.
- **`Graphic` as a `pygfx.WorldObject`**: Each `fastplotlib.Graphic` corresponds to a `pygfx.WorldObject` which is the object that exists in the 3D scene. fastplotlib manages the lifecycle of these objects to prevent memory leaks, especially in interactive environments like Jupyter.
- **Graphic Features**: The mutable properties of a graphic (e.g., `data`, `colors`, `cmap`) are implemented as "Graphic Features". These are evented objects, typically found in the `fastplotlib.graphics.features` module.
    - **Example: `VertexPositions`**: When you modify `line.data`, you are interacting with a `VertexPositions` feature object. This object manages the underlying `pygfx.Buffer` that stores vertex data on the GPU. When the data is set, the feature marks the buffer for upload to the GPU before the next render and fires a "data" event.
    - **Example: `VertexColors`**: This feature manages color information. It can parse various user inputs (e.g., color names like `"red"`, hex strings, or RGBA arrays) into a standardized RGBA format for the GPU buffer.
- **Inheritance**: More complex graphics build upon simpler ones. For example, `LineGraphic` and `ScatterGraphic` both inherit from a `PositionsGraphic` base class that provides the common `data` feature (`VertexPositions`).

##### 16.2. Layouts Architecture

- **`PlotArea` Base Class**: The core of the layout system. A `Subplot` is a `PlotArea`. It encapsulates the essential `pygfx` components for a renderable scene:
    - **`scene`**: A `pygfx.Scene` that contains the `world_object`s of the graphics.
    - **`camera`**: A `pygfx.Camera` that defines the viewpoint into the scene.
    - **`controller`**: A `pygfx.Controller` that manipulates the camera (pan, zoom, orbit).
    - **`renderer`**: A `pygfx.WgpuRenderer` instance that performs the drawing.
    - **`viewport`**: A `pygfx.Viewport` that maps the renderer's output to a specific rectangular area on the canvas.
- **`Figure`**: The `Figure` object orchestrates the layout. It creates a single shared canvas for all its subplots. It then divides this canvas into multiple `Viewport`s, one for each `Subplot`, effectively creating the grid or custom layout.
- **`Subplot`**: Implements the `PlotArea` and adds methods for easily adding graphics (e.g., `add_line`, `add_image`). It also manages "docks", which are special `PlotArea`s at the edges used for tools like the `HistogramLUTTool`.

#### 17. Testing

fastplotlib employs a two-layer testing strategy to ensure correctness.

1.  **Backend/Unit Tests**: Located in the `/tests` directory, these use `pytest` to verify the core functionality of buffer management, graphic features, layouts, and other non-visual components. These tests are often run in an offscreen mode.
2.  **Visual Regression Tests**: Since fastplotlib is a plotting library, visual correctness is critical. This is tested by:
    - Running every example script in the `examples/` directory.
    - Taking a screenshot of the resulting plot.
    - Comparing this screenshot to a "ground-truth" image stored in the repository using `git-lfs`.
    - A test passes if the Root Mean Square Error (RMSE) between the generated image and the ground-truth is below a small tolerance.
    - If a test fails, a difference image is generated in a `diffs` directory to highlight the changes.

**For Contributors:** If your changes intentionally alter the visual output of an example, you must update the ground-truth screenshots. This involves downloading the newly generated screenshots from the GitHub Actions CI run for your pull request and committing them to your branch.

#### 18. Core Dependencies and Technology Stack

Understanding the stack helps in debugging and extending the library.

-   **`pygfx`**: The core scene graph and rendering framework that provides the object-oriented 3D model. fastplotlib is a high-level API for `pygfx`.
-   **`wgpu-py`**: The Python wrapper around `wgpu-native`, providing access to the modern GPU APIs (Vulkan, Metal, DX12). It manages the low-level GPU communication.
-   **`numpy`**: Used extensively for data representation and manipulation. The fastplotlib API is designed to feel familiar to NumPy users.
-   **`pylinalg`**: A new dependency used for linear algebra operations, ensuring performant calculations for transformations.
-   **GUI Backends**:
    -   `jupyter_rfb`: For rendering in JupyterLab via a remote frame buffer.
    -   `PyQt6`/`PySide6`: For integration into desktop applications.
    -   `glfw`: For creating standalone, lightweight windows.
    -   `wxPython`: Supported, but less tested.
-   **Optional UI**:
    -   `imgui-bundle`: For creating immediate-mode GUIs inside the plot canvas.
    -   `ipywidgets`: For creating traditional callback-based UIs in Jupyter.

#### 19. Project Status and Roadmap

-   **Development Stage**: `fastplotlib` is in **late alpha**. The API is largely stable, but changes are still possible, and users may encounter bugs.
-   **Roadmap**: The project maintains a public roadmap on the GitHub repository's issues page (e.g., "Roadmap for 2025"). This outlines future plans and is a great place to find contribution ideas.
-   **Releases**: The library follows semantic versioning (MAJOR.MINOR.PATCH). New releases are created on GitHub and distributed via PyPI.

#### 20. Common Questions & Troubleshooting

-   **Is fastplotlib for static publication figures?**
    No. While figures can be exported as PNGs (`figure.export()`), the library is optimized for *interactive* GPU-based visualization. For high-quality static plots, libraries like Matplotlib or Seaborn are better suited.

-   **How does fastplotlib relate to Matplotlib?**
    It doesn't. They are completely separate projects with different goals and architectures. `fastplotlib`'s design philosophy is closer to NumPy's array-based manipulation than Matplotlib's object hierarchy.

-   **Why is my plot not showing or the kernel crashing?**
    -   **VRAM:** You may have run out of GPU memory. Try reducing the size or number of graphics.
    -   **Drivers:** The most common cause of issues. Ensure your GPU drivers are up-to-date and support Vulkan (or Metal on macOS).
    -   **`fpl.loop.run()`:** In standalone scripts, you must call `fpl.loop.run()` at the end to start the event loop and keep the window open. This is not needed in Jupyter notebooks.

-   **I see strange visual artifacts or glitches.**
    This is almost always a GPU driver issue. Update to the latest stable drivers from your GPU manufacturer (NVIDIA, AMD, Intel). On Linux, you may also need to ensure `mesa-vulkan-drivers` are installed.