### fastplotlib Documentation for LLMs

#### 1. Overview

fastplotlib is a high-performance, interactive scientific plotting library for Python. It is built on the `pygfx` rendering engine, which utilizes modern graphics backends like Vulkan, Metal, or DX12 via WGPU. This allows for GPU-accelerated visualization of large-scale data. The library is designed with an expressive and intuitive API, similar in feel to NumPy, to facilitate rapid prototyping and exploratory data analysis. fastplotlib is currently in a late alpha stage.

- **Homepage:** https://www.fastplotlib.org/
- **Repository:** https://github.com/fastplotlib/fastplotlib
- **License:** Apache 2.0

#### 2. Key Features

- **GPU-Accelerated:** Leverages the GPU for fast rendering of complex scenes and large datasets.
- **Interactive API:** An expressive, array-like API for manipulating plot elements dynamically.
- **Cross-Platform & Framework-Agnostic:** Runs on Linux, Windows, and macOS. It can be used in Jupyter Lab, PyQt/PySide applications, GLFW windows, and wxPython.
- **Multiple Graphic Types:** Supports images, lines, scatter plots, text, line collections, and more.
- **Event System:** Comprehensive event system for handling user interactions (mouse, keyboard) and property changes on graphics.
- **UI Integration:** Easily integrates with UI libraries like `imgui` and `ipywidgets`.
- **Large Data Exploration:** Optimized for exploring and rendering large-scale scientific data, including multi-dimensional arrays and real-time data streams.

#### 3. Core Concepts

The main components of a fastplotlib visualization are:

- **`Figure`**: The top-level container for the entire visualization. It can hold one or more `Subplot` objects in a grid or custom layout. It manages the canvas, renderer, and controllers.
- **`Subplot`**: A single plotting area within a `Figure`. It contains the graphics, axes, and its own camera and controller. You add graphics to a `Subplot`.
- **`Graphic`**: A visual representation of data. Examples include `ImageGraphic`, `LineGraphic`, and `ScatterGraphic`. Graphics are added to `Subplot` objects. They have mutable properties (called "features") like `data`, `colors`, `cmap`, and `visible` that can be changed dynamically.
- **`GraphicCollection`**: A collection of `Graphic` objects that can be manipulated as a group, such as `LineCollection` or `LineStack`.
- **Selectors**: Interactive tools like `LinearSelector` and `LinearRegionSelector` that can be added to graphics to select data points or regions.
- **`ImageWidget`**: A high-level widget for displaying and navigating multi-dimensional image data (2D, 3D, 4D) with built-in sliders and a histogram LUT.

#### 4. Installation

fastplotlib can be installed using pip. Optional dependencies can be included for different environments.

**Recommended installation (includes JupyterLab and `imgui` support):**
```bash
pip install -U "fastplotlib[notebook,imgui]"
```

**Minimal installation:**
```bash
pip install -U fastplotlib
```

**For use in JupyterLab:**
```bash
pip install -U "fastplotlib[notebook]"
```

**For `imgui` support:**
```bash
pip install -U "fastplotlib[imgui]"
```

For optimal performance in notebooks, it is recommended to install `simplejpeg` after installing `libjpeg-turbo`.

#### 5. Basic Usage

The API is designed to be concise and intuitive.

**Example: Simple Image Plot**
```python
import fastplotlib as fpl
import imageio.v3 as iio

# Create a Figure with a default 1x1 subplot layout
fig = fpl.Figure()

# Load image data
data = iio.imread("imageio:camera.png")

# Get the subplot at position and add an image graphic
image_graphic = fig.add_image(data=data, name="camera")

# Show the plot
fig.show()

# Run the event loop (for standalone scripts)
if __name__ == "__main__":
    fpl.loop.run()
```

#### 6. The API in Detail

##### 6.1. Creating Figures and Subplots

```python
# Create a figure with a single subplot
fig = fpl.Figure()
subplot = fig

# Create a 2x3 grid of subplots
fig_grid = fpl.Figure(shape=(2, 3))

# Access a specific subplot
subplot_1_2 = fig_grid

# Sync cameras and controllers across all subplots
fig_sync = fpl.Figure(shape=(2, 2), controller_ids="sync")
```

##### 6.2. Adding Graphics

Graphics are added to subplots.

```python
# Add a line plot from x, y data
xs = np.linspace(-10, 10, 100)
ys = np.sin(xs)
sine_data = np.column_stack([xs, ys])
line = subplot.add_line(data=sine_data, colors="magenta", thickness=3)

# Add a scatter plot
points = np.random.rand(100, 2) * 200
scatter = subplot.add_scatter(data=points, sizes=5, cmap="viridis")

# Add an image
img_data = np.random.rand(256, 256)
image = subplot.add_image(data=img_data, cmap="jet")
```

##### 6.3. Interacting with Graphic Properties

Graphic properties can be accessed and modified directly. Many properties support NumPy-style slicing.

```python
# Change the colormap of an image
image.cmap = "hot"

# Change the contrast limits
image.vmin = 0.2
image.vmax = 0.8

# Change the color of a line
line.colors = "cyan"

# Modify a slice of the line's data
line.data[50:, 1] *= 0.5 # Halve the y-values of the second half of the line

# Use boolean indexing on colors
line.colors[line.data[:, 1] < 0] = "red"

# Change a slice of a line's colormap
line.cmap[0:25] = "viridis"
```

##### 6.4. Event Handling

Event handlers can be attached to graphics or the figure's renderer to respond to user input or property changes.

**Attaching an event handler:**
```python
# Using a decorator
@image.add_event_handler("click")
def my_click_handler(event):
    # event.pick_info contains info about the clicked element
    print(f"Clicked on Image at index: {event.pick_info['index']}")

# Using the method
def my_cmap_handler(event):
    # event.info contains details about the property change
    print(f"Image colormap changed to: {event.info['value']}")

image.add_event_handler(my_cmap_handler, "cmap")
```

**Common Event Types:**
-   **Canvas Events:** `click`, `double_click`, `pointer_down`, `pointer_up`, `pointer_move`, `wheel`, `key_down`, `key_up`.
-   **Property Events:** A new event is fired whenever a mutable property (like `data`, `colors`, `cmap`, `vmin`, `visible`, etc.) is changed. The event type is the name of the property.

##### 6.5. Using Selectors

Selectors are tools for interactive data selection.

```python
# Add a vertical line selector to a line graphic
selector = line.add_linear_selector(axis='x')

@selector.add_event_handler("selection")
def on_selection(event):
    # Get the data index under the selector
    selected_index = event.get_selected_index()
    # event.info['value'] has the new selector position
    print(f"Selector at index: {selected_index}, position: {event.info['value']:.2f}")
```

#### 7. Supported Environments

- **JupyterLab:** `fastplotlib` integrates with `ipywidgets`. Figures can be displayed inline, in a `sidecar`, or laid out using `VBox` and `HBox`. This works with remote kernels.
- **Qt (PyQt6/PySide6):** Figures can be embedded as widgets in a Qt application.
- **GLFW:** Figures can be shown in a standalone GLFW window. This is the default for running scripts from the terminal.
- **ipython:** Supports Qt or GLFW backends. To use Qt, run `%gui qt` before importing `fastplotlib`.

#### 8. Contribution Guide

- Contributions are welcome and follow the Git feature branch workflow.
- Fork the repository, create a new branch for your feature or bugfix.
- Code style follows `black`.
- Tests are written using `pytest`. For visual changes, screenshot-based tests are used. Ground-truth images are stored in `git-lfs`.
- Pull requests should be made against the `main` branch.
- Public methods and classes require `numpydoc` style docstrings with type annotations.

#### 9. Project Governance

- The project is led by **Maintainers** (core developers) and guided by an **Advisory Committee**.
- Decisions are made through a "consensus-seeking" process, primarily on the GitHub issue tracker and discussions.
- The project has a formal Code of Conduct and a conflict resolution process managed by a neutral moderator.

```text
#### 10. Animations

fastplotlib allows you to define functions that are called on every render cycle, making it easy to create animations.

- **`add_animations(callback)`**: This method can be called on a `Subplot` object.
- **Callback Function**: The provided callback function must accept the `Subplot` instance as its only argument. Inside this function, you can update the data or properties of any graphic within that subplot.

**Example: Animating a Sine Wave**
```python
import fastplotlib as fpl
import numpy as np

# Initial data
xs = np.linspace(0, 10, 100)
ys = np.sin(xs)
data = np.column_stack([xs, ys])

fig = fpl.Figure()
line = fig.add_line(data=data, name="dynamic_sine")

# This animation function is called on every frame
def update_wave(subplot):
    # `subplot.graphics` holds all graphics. We select ours by name.
    # Update the y-values of the line's data buffer.
    # This is highly efficient as it only updates the buffer on the GPU.
    subplot["dynamic_sine"].data[:, 1] = np.sin(xs + fpl.loop.time)

# Register the animation function with the subplot
fig.add_animations(update_wave)

fig.show()

if __name__ == "__main__":
    fpl.loop.run()


#### 11. Advanced Graphics

##### 11.1. LineCollection and LineStack

- **`LineCollection`**: Efficiently plots and manages a large number of `LineGraphic` objects. All lines in the collection can be manipulated together (e.g., changing `cmap`) or individually by indexing the collection.
- **`LineStack`**: A subclass of `LineCollection` that automatically arranges lines in a stack with a specified separation along the y-axis.

**Example: Plotting a `LineStack`**```python
import numpy as np
import fastplotlib as fpl

# Create data for 10 sine waves
xs = np.linspace(0, np.pi * 10, 100)
ys = np.sin(xs)
sine_wave = np.column_stack([xs, ys])
data_stack = np.stack([sine_wave] * 10) # Shape: (10, 100, 2)

fig = fpl.Figure()

# Add a line stack, each line will be separated by 3 units on the y-axis
# The colormap 'jet' will be applied across the stack of lines
line_stack = fig.add_line_stack(
    data_stack,
    thickness=3,
    separation=3,
    cmap="jet"
)

fig.show()

if __name__ == "__main__":
    fpl.loop.run()
```

Slicing `LineCollection` and `LineStack` objects allows for powerful, vectorized modifications.

```python
# Change the color of the first 3 lines in the stack
line_stack[0:3].colors = "magenta"

# Use fancy indexing based on a property
# Make all lines with thickness > 4 red
line_stack[line_stack.thickness > 4].colors = "r"

# Slice both the collection and the data within each line
# Set the alpha of the first 50 points of every other line to 0.5
line_stack[::2].colors[:50, -1] = 0.5
```

#### 12. UI Integration

fastplotlib is designed to work seamlessly with popular UI toolkits for building interactive applications.

##### 12.1. `imgui`

`imgui-bundle` allows for creating immediate-mode GUIs that are rendered directly onto the same canvas as the plot. This makes them backend-agnostic (working in Jupyter, Qt, and GLFW).

- **`ImguiFigure`**: A special figure class for `imgui` integration.
- **`EdgeWindow`**: A base class for creating custom UI windows that are docked to the edges of the plot.
- **`figure.add_gui(my_gui)`**: Adds a custom GUI instance to the figure.

**Conceptual Example: `imgui` UI**
```python
from fastplotlib.ui import EdgeWindow
from imgui_bundle import imgui

class MyGUI(EdgeWindow):
    def __init__(self, figure, size, location, title, line_graphic):
        super().__init__(figure, size, location, title)
        self.line = line_graphic
        self.amplitude = 1.0

    # The update method is called every frame to draw the UI
    def update(self):
        # Create a slider for amplitude
        changed, new_amplitude = imgui.slider_float(
            "Amplitude", self.amplitude, 0.1, 5.0
        )
        if changed:
            self.amplitude = new_amplitude
            # Update the line data based on the new amplitude
            self.line.data[:, 1] = np.sin(xs) * self.amplitude

# In main script:
# fig = fpl.ImguiFigure()
# line = fig.add_line(...)
# my_gui = MyGUI(fig, size=250, location="right", title="Controls", line_graphic=line)
# fig.add_gui(my_gui)
# fig.show()
```

##### 12.2. `ipywidgets`

In JupyterLab, `ipywidgets` can be used to control plot features. The `figure.show()` method returns a widget that can be composed with other ipywidgets.

**Conceptual Example: `ipywidgets`**
```python
from ipywidgets import FloatSlider, VBox

# fig = fpl.Figure()
# line = fig.add_line(...)

# Create a slider
slider = FloatSlider(min=0.1, max=5.0, value=1.0, description="Amplitude")

# Define a callback
def update_amplitude(change):
    line.data[:, 1] = np.sin(xs) * change["new"]

# Link the slider to the callback
slider.observe(update_amplitude, "value")

# Display the figure and the slider together
VBox([fig.show(), slider])
```

#### 13. ImageWidget

The `ImageWidget` is a high-level component that simplifies the visualization of multi-dimensional image and video data. It automatically creates:

- A `Figure` with subplots for each image.
- Sliders for navigating through extra dimensions (e.g., time or z-stacks).
- A histogram LUT (Look-Up Table) for interactive contrast adjustment (`vmin`/`vmax`).
- A colorbar with a right-click menu to change colormaps.

**Example: Viewing a Video**
```python
import fastplotlib as fpl
import imageio.v3 as iio

# Load a video file (T, H, W, C)
video_data = iio.imread("imageio:cockatoo.mp4")

# The ImageWidget automatically creates a slider for the 't' dimension
iw = fpl.ImageWidget(data=video_data, rgb=True)

iw.show()
```

#### 14. Coordinate Systems

Understanding the different coordinate systems is key for advanced interactions.

- **World Space**: The 3D space where all graphics (`world_object`s) reside. The camera looks into this space.
- **Data Space**: World space transformed by a graphic's specific `offset` and `rotation`. This is the coordinate system of the raw data provided to the graphic.
- **Screen Space**: The 2D pixel space of the canvas/window. The renderer projects from world space to screen space.
- **`subplot.map_screen_to_world((x, y))`**: A crucial utility function to convert mouse coordinates (screen space) to the corresponding location in the 3D world space.

#### 15. GPU Management

Since `fastplotlib` is GPU-based, understanding how to manage the GPU is important for performance and stability.

- **Driver Requirements**: Up-to-date and properly configured GPU drivers are essential. Vulkan is used on Linux/Windows, and Metal on macOS.
- **Adapter Selection**: `fastplotlib` will automatically select a GPU (adapter), prioritizing discrete GPUs. You can manually inspect and select a GPU.
- **`fpl.enumerate_adapters()`**: Returns a list of available GPU adapters.
- **`fpl.select_adapter(adapter)`**: Sets the adapter to be used. **This must be called before creating any `Figure`**.
- **`fpl.print_wgpu_report()`**: Prints a detailed diagnostic report, including the active GPU, memory usage, and supported features. This is useful for debugging.


#### 16. Deeper Architectural Concepts

For advanced users and contributors, understanding the underlying architecture is beneficial. This is based on the `pygfx` rendering engine.

##### 16.1. Graphics Architecture

- **`Graphic` Base Class**: All graphic types (`ImageGraphic`, `LineGraphic`, etc.) inherit from the base `Graphic` class. It manages common properties and wraps a `pygfx.WorldObject`.
- **`Graphic` as a `pygfx.WorldObject`**: Each `fastplotlib.Graphic` corresponds to a `pygfx.WorldObject` which is the object that exists in the 3D scene. fastplotlib manages the lifecycle of these objects to prevent memory leaks, especially in interactive environments like Jupyter.
- **Graphic Features**: The mutable properties of a graphic (e.g., `data`, `colors`, `cmap`) are implemented as "Graphic Features". These are evented objects, typically found in the `fastplotlib.graphics.features` module.
    - **Example: `VertexPositions`**: When you modify `line.data`, you are interacting with a `VertexPositions` feature object. This object manages the underlying `pygfx.Buffer` that stores vertex data on the GPU. When the data is set, the feature marks the buffer for upload to the GPU before the next render and fires a "data" event.
    - **Example: `VertexColors`**: This feature manages color information. It can parse various user inputs (e.g., color names like `"red"`, hex strings, or RGBA arrays) into a standardized RGBA format for the GPU buffer.
- **Inheritance**: More complex graphics build upon simpler ones. For example, `LineGraphic` and `ScatterGraphic` both inherit from a `PositionsGraphic` base class that provides the common `data` feature (`VertexPositions`).

##### 16.2. Layouts Architecture

- **`PlotArea` Base Class**: The core of the layout system. A `Subplot` is a `PlotArea`. It encapsulates the essential `pygfx` components for a renderable scene:
    - **`scene`**: A `pygfx.Scene` that contains the `world_object`s of the graphics.
    - **`camera`**: A `pygfx.Camera` that defines the viewpoint into the scene.
    - **`controller`**: A `pygfx.Controller` that manipulates the camera (pan, zoom, orbit).
    - **`renderer`**: A `pygfx.WgpuRenderer` instance that performs the drawing.
    - **`viewport`**: A `pygfx.Viewport` that maps the renderer's output to a specific rectangular area on the canvas.
- **`Figure`**: The `Figure` object orchestrates the layout. It creates a single shared canvas for all its subplots. It then divides this canvas into multiple `Viewport`s, one for each `Subplot`, effectively creating the grid or custom layout.
- **`Subplot`**: Implements the `PlotArea` and adds methods for easily adding graphics (e.g., `add_line`, `add_image`). It also manages "docks", which are special `PlotArea`s at the edges used for tools like the `HistogramLUTTool`.

#### 17. Testing

fastplotlib employs a two-layer testing strategy to ensure correctness.

1.  **Backend/Unit Tests**: Located in the `/tests` directory, these use `pytest` to verify the core functionality of buffer management, graphic features, layouts, and other non-visual components. These tests are often run in an offscreen mode.
2.  **Visual Regression Tests**: Since fastplotlib is a plotting library, visual correctness is critical. This is tested by:
    - Running every example script in the `examples/` directory.
    - Taking a screenshot of the resulting plot.
    - Comparing this screenshot to a "ground-truth" image stored in the repository using `git-lfs`.
    - A test passes if the Root Mean Square Error (RMSE) between the generated image and the ground-truth is below a small tolerance.
    - If a test fails, a difference image is generated in a `diffs` directory to highlight the changes.

**For Contributors:** If your changes intentionally alter the visual output of an example, you must update the ground-truth screenshots. This involves downloading the newly generated screenshots from the GitHub Actions CI run for your pull request and committing them to your branch.

#### 18. Core Dependencies and Technology Stack

Understanding the stack helps in debugging and extending the library.

-   **`pygfx`**: The core scene graph and rendering framework that provides the object-oriented 3D model. fastplotlib is a high-level API for `pygfx`.
-   **`wgpu-py`**: The Python wrapper around `wgpu-native`, providing access to the modern GPU APIs (Vulkan, Metal, DX12). It manages the low-level GPU communication.
-   **`numpy`**: Used extensively for data representation and manipulation. The fastplotlib API is designed to feel familiar to NumPy users.
-   **`pylinalg`**: A new dependency used for linear algebra operations, ensuring performant calculations for transformations.
-   **GUI Backends**:
    -   `jupyter_rfb`: For rendering in JupyterLab via a remote frame buffer.
    -   `PyQt6`/`PySide6`: For integration into desktop applications.
    -   `glfw`: For creating standalone, lightweight windows.
    -   `wxPython`: Supported, but less tested.
-   **Optional UI**:
    -   `imgui-bundle`: For creating immediate-mode GUIs inside the plot canvas.
    -   `ipywidgets`: For creating traditional callback-based UIs in Jupyter.

#### 19. Project Status and Roadmap

-   **Development Stage**: `fastplotlib` is in **late alpha**. The API is largely stable, but changes are still possible, and users may encounter bugs.
-   **Roadmap**: The project maintains a public roadmap on the GitHub repository's issues page (e.g., "Roadmap for 2025"). This outlines future plans and is a great place to find contribution ideas.
-   **Releases**: The library follows semantic versioning (MAJOR.MINOR.PATCH). New releases are created on GitHub and distributed via PyPI.

#### 20. Common Questions & Troubleshooting

-   **Is fastplotlib for static publication figures?**
    No. While figures can be exported as PNGs (`figure.export()`), the library is optimized for *interactive* GPU-based visualization. For high-quality static plots, libraries like Matplotlib or Seaborn are better suited.

-   **How does fastplotlib relate to Matplotlib?**
    It doesn't. They are completely separate projects with different goals and architectures. `fastplotlib`'s design philosophy is closer to NumPy's array-based manipulation than Matplotlib's object hierarchy.

-   **Why is my plot not showing or the kernel crashing?**
    -   **VRAM:** You may have run out of GPU memory. Try reducing the size or number of graphics.
    -   **Drivers:** The most common cause of issues. Ensure your GPU drivers are up-to-date and support Vulkan (or Metal on macOS).
    -   **`fpl.loop.run()`:** In standalone scripts, you must call `fpl.loop.run()` at the end to start the event loop and keep the window open. This is not needed in Jupyter notebooks.

-   **I see strange visual artifacts or glitches.**
    This is almost always a GPU driver issue. Update to the latest stable drivers from your GPU manufacturer (NVIDIA, AMD, Intel). On Linux, you may also need to ensure `mesa-vulkan-drivers` are installed.


    Of course. Here is an overview of the `fastplotlib` Python library based on the provided example files.

    ### General Overview

    `fastplotlib` is a high-performance, GPU-accelerated plotting library built on top of `pygfx`, which in turn uses `wgpu` (a Python implementation of WebGPU). Its primary design goal is to enable fast, interactive visualization of large datasets, including images, videos, and massive scatter or line plots.

    The library's API is object-oriented, centered around a `Figure` object that contains one or more `Subplot`s. You add visuals to these subplots by creating `Graphic` objects like `ImageGraphic`, `LineGraphic`, or `ScatterGraphic`.

    Key characteristics of `fastplotlib` include:

    *   **Performance:** By leveraging the GPU, it can render millions of data points and large images/videos smoothly and animate them in real-time.
    *   **Interactivity:** It has a rich event system that allows for creating highly interactive plots. You can respond to clicks, mouse movements, and key presses to update plots, highlight data, or build complex data exploration tools.
    *   **Integration:** It seamlessly integrates into different environments:
        *   **Jupyter Notebooks/Lab:** It works out-of-the-box in Jupyter and can be controlled using `ipywidgets`.
        *   **Qt Applications:** A `fastplotlib` Figure can be embedded as a standard widget within a PyQt or PySide application.
        *   **ImGUI:** It offers an `ImguiFigure` for creating powerful, in-window graphical user interfaces to control plot properties.
    *   **Specialized Widgets:** It provides high-level components like the `ImageWidget`, which is a powerful tool for viewing and navigating multi-dimensional image stacks and videos with built-in sliders and histogram LUTs.

    ---

    ### How-To Guide

    Here are the answers to your specific questions based on the provided examples.

    #### How to make a scatter plot?

    Yes, this is a core feature of the library. You can create a scatter plot by calling the `add_scatter()` method on a `Subplot` object.

    The data should be a NumPy array of shape `(n_points, 2)` for 2D plots or `(n_points, 3)` for 3D plots. You can customize properties like `sizes`, `colors`, and `alpha`.

    **Example Code:**
    ```python
    import fastplotlib as fpl
    import numpy as np

    # Create a figure with one subplot
    figure = fpl.Figure(size=(700, 560))

    # Get the subplot object
    subplot = figure[0, 0]

    # Generate 5,000 random 3D points
    n_points = 5_000
    data_cloud = np.random.normal(size=(n_points, 3), scale=5)

    # Add the scatter plot to the subplot
    scatter_graphic = subplot.add_scatter(data=data_cloud, sizes=3, colors="cyan", alpha=0.7)

    # Show the plot
    figure.show()
    ```
    *(This is based on `./examples/scatter/scatter.py`)*

    ---

    #### How to change the limits of the x-axis?

    Yes, this is possible, but it's handled by manipulating the subplot's **camera** rather than setting axis limits directly like in Matplotlib. The camera controls what portion of the world space is visible.

    The most common way to change limits is interactively by using the built-in pan and zoom controllers. Programmatically, you can change the camera's `width`, `height`, and `position`.

    *   To set the x-limits from `xmin` to `xmax`, you would set the camera's `width` to `xmax - xmin` and its `x` position to the center of that range, `(xmin + xmax) / 2`.

    **Example Code:**
    ```python
    import fastplotlib as fpl
    import numpy as np

    figure = fpl.Figure()
    subplot = figure[0, 0]

    xs = np.linspace(0, 100, 1000)
    ys = np.sin(xs)
    line = subplot.add_line(np.column_stack([xs, ys]))

    # To set the view to show the x-axis from x=20 to x=50:
    xmin, xmax = 20, 50

    subplot.camera.width = xmax - xmin  # Set the range of the view
    subplot.camera.local.x = (xmin + xmax) / 2  # Set the center of the view

    figure.show()
    ```
    You can also use `subplot.auto_scale()` to automatically adjust the view to fit all the data.

    ---

    #### How to make x and y axis logarithmic?

    Based on the provided example files, **this feature does not appear to be directly supported.** There are no methods like `set_xscale("log")` or `log=True` arguments in any of the plotting calls.

    The library focuses on rendering data directly on a linear scale, leveraging the GPU for speed.

    **Workaround:** You must transform your data *before* plotting it. For example, to plot data on a log-log scale, you would do the following:

    **Example Code:**
    ```python
    import fastplotlib as fpl
    import numpy as np

    figure = fpl.Figure()
    subplot = figure[0, 0]

    # Original linear data
    x_linear = np.linspace(1, 1000, 100)
    y_linear = x_linear**2

    # Manually transform data to a log scale
    x_log = np.log10(x_linear)
    y_log = np.log10(y_linear)

    # Plot the transformed data
    data_log = np.column_stack([x_log, y_log])
    subplot.add_line(data_log)

    # You would need to manually set tick labels if you want them to reflect the original scale.
    # The library's focus is on raw performance, so such features might be less developed.
    subplot.title = "Data plotted on a log-log scale"

    figure.show()
    ```

    ---

    #### How to export the plot into a png file?

    Yes, this is possible using the `figure.export()` method. This method uses the `imageio` library internally, so you must have it installed (`pip install imageio`).

    **Example Code:**
    ```python
    import fastplotlib as fpl
    import imageio.v3 as iio

    figure = fpl.Figure(size=(700, 560))

    # Load some example image data
    data = iio.imread("imageio:camera.png")

    # Plot the image data
    image = figure[0, 0].add_image(data=data)

    # Show the figure (optional if running in a script and just want to save)
    figure.show()

    # Export the figure to a PNG file
    figure.export("my_plot.png")
    ```
    *(This functionality is demonstrated in the test suite file `./tests/test_examples.py` and defined in `layouts/_figure.py`.)*

    ---

    ### More About the Library

    Based on the examples, here are some other significant features of `fastplotlib`:

    *   **Rich Graphic Types:** Beyond scatter plots, it has first-class support for:
        *   **Images & Videos:** `add_image` can handle 2D grayscale, RGB, and RGBA data. The `ImageWidget` is specifically designed for multi-dimensional data like videos (`t, y, x, c`) or z-stacks (`z, y, x, c`).
        *   **Lines:** `add_line` for single line plots, and `add_line_collection` or `add_line_stack` for efficiently plotting thousands of lines.
        *   **Text:** `add_text` for adding annotations to plots.

    *   **Powerful Layouts:** You are not restricted to a simple grid. The `Figure` can be configured with:
        *   A simple grid using `shape=(rows, cols)`.
        *   A custom layout defined by `rects` (x, y, width, height) or `extents` (xmin, xmax, ymin, ymax) in either fractional or absolute pixel coordinates. This allows for complex, non-uniform arrangements of subplots.

    *   **The `ImageWidget`:** This is a standout feature. It's a high-level widget that automatically creates a figure, sliders for extra dimensions (like time or z-depth), and an interactive histogram with a Look-Up Table (LUT) for adjusting contrast and colormaps. It is ideal for scientific image analysis. *(See `./examples/image_widget/image_widget.py`)*

    *   **Event Handling:** You can attach custom functions to events like `click`, `pointer_move`, or even changes to a graphic's properties (like its `data` or `cmap`). This enables building sophisticated, interactive applications where plots are linked or data can be manipulated directly with the mouse. *(See `./examples/events/drag_points.py` and `scatter_hover.py`)*

    *   **Selection Tools:** The library provides selector graphics like `LinearSelector`, `LinearRegionSelector`, and `RectangleSelector` that can be added to other graphics. These tools allow users to interactively select regions of data and trigger callbacks to analyze or visualize the selection. *(See `./examples/selection_tools/fft.py`)*